<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Puzzle</title>

<link rel="manifest" href="manifest.json">

<style>
body {
  margin: 0;
  background: #111;
  color: #fff;
  font-family: Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
}

#top { padding: 10px; }

#board {
  position: relative;
  background: #000;
  border: 2px solid #333;
  touch-action: none;
}

.piece {
  position: absolute;
  border: 1px solid #222;
  background-repeat: no-repeat;
  transition: left .2s ease, top .2s ease;
}

.piece.dragging {
  transition: none;
  z-index: 10;
}

.piece.locked {
  border: none;
}

#win {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.7);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 32px;
  opacity: 0;
  pointer-events: none;
  transition: opacity .4s ease;
}

#win.show {
  opacity: 1;
}

.confetti {
  position: fixed;
  width: 8px;
  height: 14px;
  background: hsl(var(--h),90%,60%);
  top: -20px;
  animation: fall 1.8s linear forwards;
}

@keyframes fall {
  to {
    transform: translateY(110vh) rotate(360deg);
    opacity: 0;
  }
}
</style>
</head>

<body>

<div id="top">
  <input type="file" id="file" accept="image/*">
</div>

<div id="board"></div>
<div id="win">ðŸŽ‰ Puzzle TamamlandÄ±!</div>

<script>
/* ================= AYAR ================= */
const ROWS = 3, COLS = 5;
const SNAP_DIST = 0.35;      // yumuÅŸak snap
const MAGNET_DIST = 0.25;    // manyetik kenar

let PW, PH;
let pieces = [];
let groups = {};
let dragging = null;
let ox = 0, oy = 0;
let pointerId = null;

const board = document.getElementById("board");
const input = document.getElementById("file");

/* ================= FOTO ================= */
input.onchange = () => {
  const f = input.files[0];
  if (!f) return;
  const r = new FileReader();
  r.onload = e => createPuzzle(e.target.result);
  r.readAsDataURL(f);
};

function createPuzzle(src) {
  board.innerHTML = "";
  pieces = [];
  groups = {};

  const img = new Image();
  img.onload = () => {
    const W = Math.floor(innerWidth * 0.95);
    const H = W * (img.height / img.width);
    PW = W / COLS;
    PH = H / ROWS;

    board.style.width = W + "px";
    board.style.height = H + "px";

    let cells = [];
    for (let y=0;y<ROWS;y++)
      for (let x=0;x<COLS;x++)
        cells.push({x,y});
    cells.sort(()=>Math.random()-.5);

    let gid = 0;
    for (let y=0;y<ROWS;y++) {
      for (let x=0;x<COLS;x++) {
        const c = cells.pop();
        const el = document.createElement("div");
        el.className = "piece";
        el.style.width = PW+"px";
        el.style.height = PH+"px";
        el.style.backgroundImage = `url(${src})`;
        el.style.backgroundSize = `${W}px ${H}px`;
        el.style.backgroundPosition = `-${x*PW}px -${y*PH}px`;
        el.style.left = c.x*PW+"px";
        el.style.top  = c.y*PH+"px";

        board.appendChild(el);

        const p = {
          el,
          cx:x, cy:y,
          x:c.x, y:c.y,
          locked:false,
          gid
        };

        pieces.push(p);
        groups[gid] = [p];
        gid++;

        el.onpointerdown = e => startDrag(e,p);
      }
    }
  };
  img.src = src;
}

/* ================= DRAG ================= */
function startDrag(e,p) {
  if (p.locked || pointerId) return;
  pointerId = e.pointerId;
  dragging = groups[p.gid];

  const r = p.el.getBoundingClientRect();
  ox = e.clientX - r.left;
  oy = e.clientY - r.top;

  dragging.forEach(x=>x.el.classList.add("dragging"));
  p.el.setPointerCapture(pointerId);
}

board.onpointermove = e => {
  if (!dragging || e.pointerId !== pointerId) return;
  dragging.forEach(p=>{
    p.el.style.left =
      e.clientX - board.offsetLeft - ox +
      (p.x-dragging[0].x)*PW + "px";
    p.el.style.top =
      e.clientY - board.offsetTop - oy +
      (p.y-dragging[0].y)*PH + "px";
  });
};

board.onpointerup = () => drop();
board.onpointercancel = () => drop();

/* ================= DROP ================= */
function drop() {
  if (!dragging) return;

  const base = dragging[0];
  const rx = base.el.offsetLeft / PW;
  const ry = base.el.offsetTop  / PH;

  const tx = Math.round(rx);
  const ty = Math.round(ry);

  if (Math.abs(rx-tx) < SNAP_DIST && Math.abs(ry-ty) < SNAP_DIST) {
    dragging.forEach(p=>{
      p.x = tx + (p.x-base.x);
      p.y = ty + (p.y-base.y);
    });
  }

  applyMagnetism(dragging);

  dragging.forEach(p=>{
    p.el.style.left = p.x*PW+"px";
    p.el.style.top  = p.y*PH+"px";
    p.el.classList.remove("dragging");
  });

  pointerId = null;
  dragging = null;

  checkLockAndMerge();
}

/* ================= MANYETÄ°K KENAR ================= */
function applyMagnetism(group) {
  group.forEach(p=>{
    pieces.forEach(o=>{
      if (!o.locked || o.gid === p.gid) return;

      const dx = o.x - p.x;
      const dy = o.y - p.y;

      // saÄŸ-sol komÅŸu
      if (dy === 0 && Math.abs(dx) === 1) {
        if (Math.abs(p.el.offsetLeft - o.el.offsetLeft + dx*PW) < PW*MAGNET_DIST) {
          group.forEach(g=>{
            g.x += dx;
          });
        }
      }

      // alt-Ã¼st komÅŸu
      if (dx === 0 && Math.abs(dy) === 1) {
        if (Math.abs(p.el.offsetTop - o.el.offsetTop + dy*PH) < PH*MAGNET_DIST) {
          group.forEach(g=>{
            g.y += dy;
          });
        }
      }
    });
  });
}

/* ================= LOCK + MERGE + WIN ================= */
function checkLockAndMerge() {
  pieces.forEach(p=>{
    if (!p.locked && p.x===p.cx && p.y===p.cy) {
      p.locked = true;
      p.el.classList.add("locked");
    }
  });

  for (let a of pieces) for (let b of pieces) {
    if (a.gid===b.gid || !a.locked || !b.locked) continue;
    const right = a.cx+1===b.cx && a.x+1===b.x && a.y===b.y;
    const down  = a.cy+1===b.cy && a.y+1===b.y && a.x===b.x;
    if (right || down) {
      groups[b.gid].forEach(p=>{
        p.gid = a.gid;
        groups[a.gid].push(p);
      });
      delete groups[b.gid];
      break;
    }
  }

  if (pieces.every(p=>p.locked)) {
    showWin();
  }
}

/* ================= WIN POLISH ================= */
function showWin() {
  const win = document.getElementById("win");
  win.classList.add("show");
  navigator.vibrate?.([100,50,100]);

  for (let i=0;i<40;i++) {
    const c = document.createElement("div");
    c.className = "confetti";
    c.style.left = Math.random()*100 + "vw";
    c.style.setProperty("--h", Math.random()*360);
    document.body.appendChild(c);
    setTimeout(()=>c.remove(),1800);
  }
}
</script>

</body>
</html>
