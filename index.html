<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>Puzzle</title>

<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#111">

<style>
body {
  margin: 0;
  background: #111;
  color: #fff;
  font-family: Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
}

#top { padding: 10px; }

#board {
  position: relative;
  background: #000;
  border: 2px solid #333;
  touch-action: none;
}

.piece {
  position: absolute;
  background-repeat: no-repeat;
  border: 1px solid #222;
  transition: left .2s ease, top .2s ease;
}

.piece.dragging {
  transition: none;
  z-index: 10;
}

.piece.locked {
  border: none;
}

.buffer-line {
  position: absolute;
  left: 0;
  right: 0;
  border-top: 2px dashed #444;
}

#winOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.75);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 32px;
  font-weight: bold;
  opacity: 0;
  pointer-events: none;
  transform: scale(1.2);
  transition: opacity .4s ease, transform .4s ease;
  z-index: 999;
}
#winOverlay.show {
  opacity: 1;
  transform: scale(1);
}
</style>
</head>

<body>

<div id="top">
  <input type="file" id="imageInput" accept="image/*">
</div>

<div id="board"></div>
<div id="winOverlay">ðŸŽ‰ Puzzle TamamlandÄ±!</div>

<script>
/* ================= AYAR ================= */
const ROWS = 3;
const COLS = 5;
const BUFFER = 1;
const SNAP_THRESHOLD = 0.35;

/* ================= DOM ================= */
const board = document.getElementById("board");
const input = document.getElementById("imageInput");

/* ================= STATE ================= */
let PW, PH;
let pieces = [];
let groups = {};
let grid = [];
let dragGroup = null;
let offsetX = 0;
let offsetY = 0;
let activePointerId = null;
let finished = false;

/* ================= FOTO ================= */
input.onchange = () => {
  const file = input.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => buildPuzzle(e.target.result);
  reader.readAsDataURL(file);
};

function buildPuzzle(src) {
  const img = new Image();
  img.onload = () => setup(img, src);
  img.src = src;
}

/* ================= SETUP ================= */
function setup(img, src) {
  board.innerHTML = "";
  pieces = [];
  groups = {};
  finished = false;

  const W = Math.floor(innerWidth * 0.95);
  const H = W * (img.naturalHeight / img.naturalWidth);
  PW = W / COLS;
  PH = H / ROWS;

  board.style.width = W + "px";
  board.style.height = PH * (ROWS + BUFFER) + "px";

  const line = document.createElement("div");
  line.className = "buffer-line";
  line.style.top = PH * ROWS + "px";
  board.appendChild(line);

  let cells = [];
  for (let y = 0; y < ROWS + BUFFER; y++)
    for (let x = 0; x < COLS; x++)
      cells.push({x,y});
  cells.sort(() => Math.random() - 0.5);

  let gid = 0;
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      const c = cells.pop();
      const el = document.createElement("div");
      el.className = "piece";
      el.style.width = PW + "px";
      el.style.height = PH + "px";
      el.style.backgroundImage = `url(${src})`;
      el.style.backgroundSize = `${W}px ${H}px`;
      el.style.backgroundPosition = `-${x*PW}px -${y*PH}px`;
      board.appendChild(el);

      const p = {
        el,
        correctX: x,
        correctY: y,
        gridX: c.x,
        gridY: c.y,
        locked: false,
        groupId: gid
      };

      pieces.push(p);
      groups[gid] = [p];
      gid++;

      el.addEventListener("pointerdown", e => startDrag(e, p));
    }
  }

  rebuildGrid();
  render();

  board.onpointermove = onDrag;
  board.onpointerup = stopDrag;
  board.onpointercancel = stopDrag;
}

/* ================= GRID ================= */
function rebuildGrid() {
  grid = Array.from(
    { length: ROWS + BUFFER },
    () => Array(COLS).fill(null)
  );

  // Ã–nce kilitli parÃ§alar
  pieces.filter(p => p.locked).forEach(p => {
    grid[p.gridY][p.gridX] = p;
  });

  // Sonra kilitli olmayanlar
  pieces.filter(p => !p.locked).forEach(p => {
    if (grid[p.gridY][p.gridX] === null) {
      grid[p.gridY][p.gridX] = p;
    }
  });
}

/* ================= DRAG ================= */
function startDrag(e, p) {
  if (p.locked || activePointerId) return;

  activePointerId = e.pointerId;
  p.el.setPointerCapture(e.pointerId);
  dragGroup = groups[p.groupId];

  const r = p.el.getBoundingClientRect();
  offsetX = e.clientX - r.left;
  offsetY = e.clientY - r.top;

  dragGroup.forEach(x => x.el.classList.add("dragging"));
}

function onDrag(e) {
  if (!dragGroup || e.pointerId !== activePointerId) return;

  dragGroup.forEach(p => {
    const dx = (p.correctX - dragGroup[0].correctX) * PW;
    const dy = (p.correctY - dragGroup[0].correctY) * PH;
    p.el.style.left =
      e.clientX - board.offsetLeft - offsetX + dx + "px";
    p.el.style.top =
      e.clientY - board.offsetTop - offsetY + dy + "px";
  });
}

function stopDrag() {
  if (!dragGroup) return;

  snapGroup(dragGroup);
  dragGroup.forEach(p => p.el.classList.remove("dragging"));
  dragGroup = null;
  activePointerId = null;

  resolveCollisions();
  lockMergeAndWin();
}

/* ================= SNAP ================= */
function snapGroup(group) {
  const b = group[0];
  const rx = b.el.offsetLeft / PW;
  const ry = b.el.offsetTop / PH;
  const tx = Math.round(rx);
  const ty = Math.round(ry);

  const ok =
    Math.abs(rx - tx) < SNAP_THRESHOLD &&
    Math.abs(ry - ty) < SNAP_THRESHOLD &&
    tx >= 0 && tx < COLS &&
    ty >= 0 && ty < ROWS;

  if (!ok) return;

  group.forEach(p => {
    p.gridX = tx + (p.correctX - b.correctX);
    p.gridY = ty + (p.correctY - b.correctY);
  });
}

/* ================= COLLISION (BFS) ================= */
function resolveCollisions() {
  rebuildGrid();

  pieces.forEach(p => {
    if (p.locked) return;

    if (grid[p.gridY][p.gridX] !== p) {
      const spot = bfsEmpty(p.gridX, p.gridY);
      p.gridX = spot.x;
      p.gridY = spot.y;
      rebuildGrid();
    }
  });

  render();
}

function bfsEmpty(x, y) {
  const q = [[x, y]];
  const seen = new Set([`${x},${y}`]);
  const maxY = ROWS + BUFFER - 1;
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

  while (q.length) {
    const [cx, cy] = q.shift();
    for (const [dx, dy] of dirs) {
      const nx = cx + dx;
      const ny = cy + dy;
      const key = `${nx},${ny}`;
      if (nx < 0 || nx >= COLS || ny < 0 || ny > maxY) continue;
      if (seen.has(key)) continue;
      if (!grid[ny][nx]) return { x: nx, y: ny };
      seen.add(key);
      q.push([nx, ny]);
    }
  }

  return { x, y: maxY };
}

/* ================= LOCK + MERGE + WIN ================= */
function lockMergeAndWin() {
  pieces.forEach(p => {
    if (!p.locked &&
        p.gridX === p.correctX &&
        p.gridY === p.correctY) {
      p.locked = true;
      p.el.classList.add("locked");
    }
  });

  for (let a of pieces) {
    for (let b of pieces) {
      if (a.groupId === b.groupId) continue;
      if (!a.locked || !b.locked) continue;

      const right =
        a.correctX + 1 === b.correctX &&
        a.gridX + 1 === b.gridX &&
        a.gridY === b.gridY;

      const down =
        a.correctY + 1 === b.correctY &&
        a.gridY + 1 === b.gridY &&
        a.gridX === b.gridX;

      if (right || down) {
        groups[b.groupId].forEach(p => {
          p.groupId = a.groupId;
          groups[a.groupId].push(p);
        });
        delete groups[b.groupId];
        return;
      }
    }
  }

  if (!finished && pieces.every(p => p.locked)) {
    finished = true;
    win();
  }
}

/* ================= RENDER ================= */
function render() {
  pieces.forEach(p => {
    p.el.style.left = p.gridX * PW + "px";
    p.el.style.top  = p.gridY * PH + "px";
  });
}

/* ================= WIN ================= */
function win() {
  const o = document.getElementById("winOverlay");
  o.classList.add("show");
  navigator.vibrate?.([100, 50, 100]);
  setTimeout(() => o.classList.remove("show"), 1500);
}
</script>

</body>
</html>
