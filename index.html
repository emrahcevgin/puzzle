<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>Puzzle</title>

<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#111">

<style>
body {
  margin: 0;
  background: #111;
  color: #fff;
  font-family: Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
}

#top { padding: 10px; }

#board {
  position: relative;
  background: #000;
  border: 2px solid #333;
  touch-action: none;
}

.piece {
  position: absolute;
  background-repeat: no-repeat;
  border: 1px solid #222;
  transition: left .2s ease, top .2s ease;
}

.piece.dragging {
  transition: none;
  z-index: 10;
}

.piece.locked {
  border: none;
}

.buffer-line {
  position: absolute;
  left: 0;
  right: 0;
  border-top: 2px dashed #444;
}

#winOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.75);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 32px;
  font-weight: bold;
  opacity: 0;
  pointer-events: none;
  transform: scale(1.2);
  transition: opacity .4s ease, transform .4s ease;
  z-index: 999;
}
#winOverlay.show {
  opacity: 1;
  transform: scale(1);
}
</style>
</head>

<body>

<div id="top">
  <input type="file" id="imageInput" accept="image/*">
</div>

<div id="board"></div>
<div id="winOverlay">ðŸŽ‰ Puzzle TamamlandÄ±!</div>

<script>
/* ================= AYAR ================= */
const ROWS = 3;
const COLS = 5;
const BUFFER = 1;
const SNAP_THRESHOLD = 0.35;

/* ================= DOM ================= */
const board = document.getElementById("board");
const input = document.getElementById("imageInput");

/* ================= STATE ================= */
let PW, PH;
let pieces = [];
let groups = {};
let grid = [];
let dragGroup = null;
let dragBase = null;
let offsetX = 0;
let offsetY = 0;
let activePointerId = null;
let finished = false;

/* ================= FOTO ================= */
input.onchange = () => {
  const file = input.files[0];
  if (!file) return;
  const r = new FileReader();
  r.onload = e => buildPuzzle(e.target.result);
  r.readAsDataURL(file);
};

function buildPuzzle(src) {
  const img = new Image();
  img.onload = () => setup(img, src);
  img.src = src;
}

/* ================= SETUP ================= */
function setup(img, src) {
  board.innerHTML = "";
  pieces = [];
  groups = {};
  finished = false;

  const W = Math.floor(innerWidth * 0.95);
  const H = W * (img.naturalHeight / img.naturalWidth);
  PW = W / COLS;
  PH = H / ROWS;

  board.style.width = W + "px";
  board.style.height = PH * (ROWS + BUFFER) + "px";

  const line = document.createElement("div");
  line.className = "buffer-line";
  line.style.top = PH * ROWS + "px";
  board.appendChild(line);

  let cells = [];
  for (let y = 0; y < ROWS + BUFFER; y++)
    for (let x = 0; x < COLS; x++)
      cells.push({x,y});
  cells.sort(() => Math.random() - 0.5);

  let gid = 0;
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      const c = cells.pop();
      const el = document.createElement("div");
      el.className = "piece";
      el.style.width = PW+"px";
      el.style.height = PH+"px";
      el.style.backgroundImage = `url(${src})`;
      el.style.backgroundSize = `${W}px ${H}px`;
      el.style.backgroundPosition = `-${x*PW}px -${y*PH}px`;
      board.appendChild(el);

      const p = {
        el,
        correctX:x,
        correctY:y,
        gridX:c.x,
        gridY:c.y,
        locked:false,
        groupId:gid
      };

      pieces.push(p);
      groups[gid] = [p];
      gid++;

      el.addEventListener("pointerdown", e => startDrag(e,p));
    }
  }

  rebuildGrid();
  render();

  board.onpointermove = onDrag;
  board.onpointerup = stopDrag;
  board.onpointercancel = stopDrag;
}

/* ================= GRID ================= */
function rebuildGrid() {
  grid = Array.from({length:ROWS+BUFFER},()=>Array(COLS).fill(null));
  pieces.forEach(p=>{
    if(grid[p.gridY] && grid[p.gridY][p.gridX]==null){
      grid[p.gridY][p.gridX]=p;
    }
  });
}

/* ================= DRAG (GROUP) ================= */
function startDrag(e,p) {
  if (p.locked || activePointerId) return;

  activePointerId = e.pointerId;
  p.el.setPointerCapture(e.pointerId);

  dragGroup = groups[p.groupId];
  dragBase = p;

  const r = p.el.getBoundingClientRect();
  offsetX = e.clientX - r.left;
  offsetY = e.clientY - r.top;

  dragGroup.forEach(x=>x.el.classList.add("dragging"));
}

function onDrag(e) {
  if (!dragGroup || e.pointerId !== activePointerId) return;

  dragGroup.forEach(p=>{
    const dx = (p.gridX - dragBase.gridX) * PW;
    const dy = (p.gridY - dragBase.gridY) * PH;
    p.el.style.left =
      e.clientX - board.offsetLeft - offsetX + dx + "px";
    p.el.style.top =
      e.clientY - board.offsetTop  - offsetY + dy + "px";
  });
}

function stopDrag() {
  if (!dragGroup) return;

  snapGroup(dragGroup, dragBase);
  dragGroup.forEach(p=>p.el.classList.remove("dragging"));
  dragGroup = null;
  dragBase = null;
  activePointerId = null;

  resolveCollisions();
  lockMergeAndWin();
}

/* ================= SNAP (GROUP) ================= */
function snapGroup(group, base) {
  const rx = base.el.offsetLeft / PW;
  const ry = base.el.offsetTop  / PH;
  const tx = Math.round(rx);
  const ty = Math.round(ry);

  const ok =
    Math.abs(rx-tx)<SNAP_THRESHOLD &&
    Math.abs(ry-ty)<SNAP_THRESHOLD &&
    tx>=0 && tx<COLS &&
    ty>=0 && ty<ROWS;

  if(!ok) return;

  group.forEach(p=>{
    p.gridX = tx + (p.gridX - base.gridX);
    p.gridY = ty + (p.gridY - base.gridY);
  });
}

/* ================= COLLISION ================= */
function resolveCollisions() {
  rebuildGrid();

  pieces.forEach(p=>{
    if(p.locked) return;
    if(grid[p.gridY][p.gridX]!==p){
      const spot = bfsEmpty(p.gridX,p.gridY);
      const dx = spot.x - p.gridX;
      const dy = spot.y - p.gridY;

      groups[p.groupId].forEach(g=>{
        g.gridX += dx;
        g.gridY += dy;
      });
      rebuildGrid();
    }
  });
  render();
}

function bfsEmpty(x,y){
  const q=[[x,y]];
  const seen=new Set([`${x},${y}`]);
  const maxY=ROWS+BUFFER-1;
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];

  while(q.length){
    const [cx,cy]=q.shift();
    for(const[dX,dY]of dirs){
      const nx=cx+dX, ny=cy+dY;
      const k=`${nx},${ny}`;
      if(nx<0||nx>=COLS||ny<0||ny>maxY||seen.has(k)) continue;
      if(!grid[ny][nx]) return {x:nx,y:ny};
      seen.add(k);
      q.push([nx,ny]);
    }
  }
  return {x,y:maxY};
}

/* ================= LOCK + MERGE + WIN ================= */
function lockMergeAndWin() {
  pieces.forEach(p=>{
    if(!p.locked &&
       p.gridX===p.correctX &&
       p.gridY===p.correctY){
      p.locked=true;
      p.el.classList.add("locked");
    }
  });

  for(let a of pieces){
    for(let b of pieces){
      if(a.groupId===b.groupId) continue;
      if(!a.locked||!b.locked) continue;

      const right =
        a.correctX+1===b.correctX &&
        a.gridX+1===b.gridX &&
        a.gridY===b.gridY;

      const down =
        a.correctY+1===b.correctY &&
        a.gridY+===b.gridY-1 &&
        a.gridX===b.gridX;

      if(right||down){
        const ga=a.groupId, gb=b.groupId;
        groups[gb].forEach(p=>{
          p.groupId=ga;
          groups[ga].push(p);
        });
        delete groups[gb];
        return;
      }
    }
  }

  if(!finished && pieces.every(p=>p.locked)){
    finished=true;
    win();
  }
}

/* ================= RENDER ================= */
function render(){
  pieces.forEach(p=>{
    p.el.style.left = p.gridX*PW+"px";
    p.el.style.top  = p.gridY*PH+"px";
  });
}

/* ================= WIN ================= */
function win(){
  const o=document.getElementById("winOverlay");
  o.classList.add("show");
  navigator.vibrate?.([100,50,100]);
  setTimeout(()=>o.classList.remove("show"),1500);
}
</script>

</body>
</html>
