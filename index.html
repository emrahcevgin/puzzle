<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>Puzzle</title>

<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#111">

<style>
body {
  margin: 0;
  background: #111;
  color: #fff;
  font-family: Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
}

#top { padding: 10px; }

#board {
  position: relative;
  background: #000;
  border: 2px solid #333;
  touch-action: none;
}

.piece {
  position: absolute;
  background-repeat: no-repeat;
  border: 1px solid #222;
  transition: left .2s ease, top .2s ease;
}

.piece.dragging {
  transition: none;
  z-index: 10;
}

.piece.locked {
  border: none;
}

.buffer-line {
  position: absolute;
  left: 0;
  right: 0;
  border-top: 2px dashed #444;
}

#winOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.75);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 32px;
  font-weight: bold;
  opacity: 0;
  pointer-events: none;
  transform: scale(1.2);
  transition: opacity .4s ease, transform .4s ease;
  z-index: 999;
}

#winOverlay.show {
  opacity: 1;
  transform: scale(1);
}
</style>
</head>

<body>

<div id="top">
  <input type="file" id="imageInput" accept="image/*">
</div>

<div id="board"></div>
<div id="winOverlay">ðŸŽ‰ Puzzle TamamlandÄ±!</div>

<script>
/* ===== SERVICE WORKER ===== */
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("service-worker.js");
}

/* ===== AYAR ===== */
const ROWS = 3;
const COLS = 5;
const BUFFER = 1;
const SNAP_THRESHOLD = 0.35;

/* ===== DOM ===== */
const board = document.getElementById("board");
const input = document.getElementById("imageInput");

/* ===== STATE ===== */
let BOARD_WIDTH, BOARD_HEIGHT, PW, PH;
let pieces = [];
let groups = {};
let nextGroupId = 0;

let dragGroup = null;
let offsetX = 0;
let offsetY = 0;
let activePointerId = null;
let finished = false;

/* ===== FOTOÄžRAF ===== */
input.onchange = () => {
  const file = input.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = e => buildPuzzle(e.target.result);
  reader.readAsDataURL(file);
};

function buildPuzzle(src) {
  const img = new Image();
  img.onload = () => setupBoard(img, src);
  img.src = src;
}

/* ===== BOARD ===== */
function setupBoard(img, src) {
  board.innerHTML = "";
  pieces = [];
  groups = {};
  nextGroupId = 0;
  finished = false;

  BOARD_WIDTH = Math.floor(document.documentElement.clientWidth * 0.95);
  BOARD_HEIGHT = BOARD_WIDTH * (img.naturalHeight / img.naturalWidth);

  PW = BOARD_WIDTH / COLS;
  PH = BOARD_HEIGHT / ROWS;

  board.style.width = BOARD_WIDTH + "px";
  board.style.height = PH * (ROWS + BUFFER) + "px";

  drawBufferLine();

  const cells = [];
  for (let y = 0; y < ROWS + BUFFER; y++)
    for (let x = 0; x < COLS; x++)
      cells.push({ x, y });
  cells.sort(() => Math.random() - 0.5);

  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      const cell = cells.pop();

      const el = document.createElement("div");
      el.className = "piece";
      el.style.width = PW + "px";
      el.style.height = PH + "px";
      el.style.backgroundImage = `url(${src})`;
      el.style.backgroundSize = `${BOARD_WIDTH}px ${BOARD_HEIGHT}px`;
      el.style.backgroundPosition = `-${x * PW}px -${y * PH}px`;
      el.style.left = cell.x * PW + "px";
      el.style.top  = cell.y * PH + "px";

      board.appendChild(el);

      const piece = {
        el,
        correctX: x,
        correctY: y,
        gridX: cell.x,
        gridY: cell.y,
        locked: false,
        groupId: nextGroupId
      };

      groups[nextGroupId] = [piece];
      nextGroupId++;
      pieces.push(piece);

      el.addEventListener("pointerdown", e => startDrag(e, piece));
    }
  }

  board.addEventListener("pointermove", onDrag);
  board.addEventListener("pointerup", stopDrag);
  board.addEventListener("pointercancel", stopDrag);
}

function drawBufferLine() {
  const line = document.createElement("div");
  line.className = "buffer-line";
  line.style.top = (PH * ROWS) + "px";
  board.appendChild(line);
}

/* ===== DRAG ===== */
function startDrag(e, piece) {
  if (piece.locked || activePointerId !== null) return;

  activePointerId = e.pointerId;
  piece.el.setPointerCapture(e.pointerId);

  dragGroup = groups[piece.groupId];
  const r = piece.el.getBoundingClientRect();
  offsetX = e.clientX - r.left;
  offsetY = e.clientY - r.top;

  dragGroup.forEach(p => p.el.classList.add("dragging"));
}

function onDrag(e) {
  if (!dragGroup || e.pointerId !== activePointerId) return;

  dragGroup.forEach(p => {
    const dx = (p.correctX - dragGroup[0].correctX) * PW;
    const dy = (p.correctY - dragGroup[0].correctY) * PH;
    p.el.style.left =
      e.clientX - board.offsetLeft - offsetX + dx + "px";
    p.el.style.top =
      e.clientY - board.offsetTop  - offsetY + dy + "px";
  });
}

function stopDrag() {
  if (!dragGroup) return;

  placeGroup(dragGroup);
  dragGroup.forEach(p => p.el.classList.remove("dragging"));
  dragGroup = null;
  activePointerId = null;

  checkLockMergeAndWin();
}

/* ===== SNAP + YERLEÅžTÄ°R ===== */
function placeGroup(group) {
  const base = group[0];

  const rawX = base.el.offsetLeft / PW;
  const rawY = base.el.offsetTop / PH;

  const tx = Math.round(rawX);
  const ty = Math.round(rawY);

  const dx = Math.abs(rawX - tx);
  const dy = Math.abs(rawY - ty);

  const canSnap =
    dx < SNAP_THRESHOLD &&
    dy < SNAP_THRESHOLD &&
    tx >= 0 && tx < COLS &&
    ty >= 0 && ty < ROWS;

  group.forEach(p => {
    if (canSnap) {
      p.gridX = tx + (p.correctX - base.correctX);
      p.gridY = ty + (p.correctY - base.correctY);
    }
    p.el.style.left = p.gridX * PW + "px";
    p.el.style.top  = p.gridY * PH + "px";
  });
}

/* ===== KÄ°LÄ°T + BÄ°RLEÅžME + KAZANMA ===== */
function checkLockMergeAndWin() {
  // Kilitle
  pieces.forEach(p => {
    if (!p.locked &&
        p.gridX === p.correctX &&
        p.gridY === p.correctY) {
      p.locked = true;
      p.el.classList.add("locked");
    }
  });

  // BirleÅŸtir
  for (let a of pieces) {
    for (let b of pieces) {
      if (a.groupId === b.groupId) continue;
      if (!a.locked || !b.locked) continue;

      const right =
        a.correctX + 1 === b.correctX &&
        a.gridX + 1 === b.gridX &&
        a.gridY === b.gridY;

      const down =
        a.correctY + 1 === b.correctY &&
        a.gridY + 1 === b.gridY &&
        a.gridX === b.gridX;

      if (right || down) {
        mergeGroups(a.groupId, b.groupId);
        return;
      }
    }
  }

  // Kazanma
  if (!finished && pieces.every(
    p => p.locked &&
         p.gridX === p.correctX &&
         p.gridY === p.correctY
  )) {
    finished = true;
    showWin();
  }
}

function mergeGroups(g1, g2) {
  const A = groups[g1];
  const B = groups[g2];
  B.forEach(p => {
    p.groupId = g1;
    A.push(p);
  });
  delete groups[g2];
}

/* ===== BÄ°TÄ°Åž ===== */
function showWin() {
  const o = document.getElementById("winOverlay");
  o.classList.add("show");

  if (navigator.vibrate) {
    navigator.vibrate([100, 50, 100]);
  }

  setTimeout(() => {
    o.classList.remove("show");
  }, 1500);
}
</script>

</body>
</html>
