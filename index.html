<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Puzzle</title>

<link rel="manifest" href="manifest.json">

<style>
body {
  margin: 0;
  background: #111;
  color: #fff;
  font-family: Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
}

#top { padding: 10px; }

#board {
  position: relative;
  background: #000;
  border: 2px solid #333;
  touch-action: none;
}

.piece {
  position: absolute;
  border: 1px solid #222;
  background-repeat: no-repeat;
  transition: left .2s ease, top .2s ease;
}

.piece.dragging {
  transition: none;
  z-index: 10;
}

.piece.locked {
  border: none;
}

.buffer-line {
  position: absolute;
  left: 0;
  right: 0;
  border-top: 2px dashed #444;
}

#win {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.7);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 32px;
  opacity: 0;
  pointer-events: none;
  transition: opacity .4s ease;
}

#win.show { opacity: 1; }
</style>
</head>

<body>

<div id="top">
  <input type="file" id="file" accept="image/*">
</div>

<div id="board"></div>
<div id="win">ðŸŽ‰ Puzzle TamamlandÄ±!</div>

<script>
/* ================= AYAR ================= */
const ROWS = 3;
const COLS = 5;
const BUFFER = 1;
const SNAP_DIST = 0.35;

let PW, PH;
let pieces = [];
let groups = {};
let dragging = null;
let ox = 0, oy = 0;
let pointerId = null;

const board = document.getElementById("board");
const input = document.getElementById("file");

/* ================= FOTO ================= */
input.onchange = () => {
  const f = input.files[0];
  if (!f) return;
  const r = new FileReader();
  r.onload = e => createPuzzle(e.target.result);
  r.readAsDataURL(f);
};

function createPuzzle(src) {
  board.innerHTML = "";
  pieces = [];
  groups = {};

  const img = new Image();
  img.onload = () => {
    const W = Math.floor(innerWidth * 0.95);
    const H = W * (img.height / img.width);
    PW = W / COLS;
    PH = H / ROWS;

    board.style.width = W + "px";
    board.style.height = PH * (ROWS + BUFFER) + "px";

    const line = document.createElement("div");
    line.className = "buffer-line";
    line.style.top = PH * ROWS + "px";
    board.appendChild(line);

    let cells = [];
    for (let y=0;y<ROWS+BUFFER;y++)
      for (let x=0;x<COLS;x++)
        cells.push({x,y});
    cells.sort(()=>Math.random()-.5);

    let gid = 0;
    for (let y=0;y<ROWS;y++) {
      for (let x=0;x<COLS;x++) {
        const c = cells.pop();
        const el = document.createElement("div");
        el.className = "piece";
        el.style.width = PW+"px";
        el.style.height = PH+"px";
        el.style.backgroundImage = `url(${src})`;
        el.style.backgroundSize = `${W}px ${H}px`;
        el.style.backgroundPosition = `-${x*PW}px -${y*PH}px`;
        el.style.left = c.x*PW+"px";
        el.style.top  = c.y*PH+"px";

        board.appendChild(el);

        const p = {
          el,
          cx:x, cy:y,
          x:c.x, y:c.y,
          locked:false,
          gid
        };

        pieces.push(p);
        groups[gid] = [p];
        gid++;

        el.onpointerdown = e => startDrag(e,p);
      }
    }
  };
  img.src = src;
}

/* ================= DRAG ================= */
function startDrag(e,p) {
  if (p.locked || pointerId) return;
  pointerId = e.pointerId;
  dragging = groups[p.gid];

  const r = p.el.getBoundingClientRect();
  ox = e.clientX - r.left;
  oy = e.clientY - r.top;

  dragging.forEach(x=>x.el.classList.add("dragging"));
  p.el.setPointerCapture(pointerId);
}

board.onpointermove = e => {
  if (!dragging || e.pointerId !== pointerId) return;
  dragging.forEach(p=>{
    p.el.style.left =
      e.clientX - board.offsetLeft - ox +
      (p.x-dragging[0].x)*PW + "px";
    p.el.style.top =
      e.clientY - board.offsetTop - oy +
      (p.y-dragging[0].y)*PH + "px";
  });
};

board.onpointerup = () => drop();
board.onpointercancel = () => drop();

/* ================= DROP + KAYMA ================= */
function drop() {
  if (!dragging) return;

  const base = dragging[0];
  const rx = base.el.offsetLeft / PW;
  const ry = base.el.offsetTop  / PH;
  const tx = Math.round(rx);
  const ty = Math.round(ry);

  if (Math.abs(rx-tx)<SNAP_DIST && Math.abs(ry-ty)<SNAP_DIST) {
    dragging.forEach(p=>{
      p.x = tx + (p.x-base.x);
      p.y = ty + (p.y-base.y);
    });
  }

  // Ã‡AKIÅžMA VARSA â†’ ALTTAKÄ° PARÃ‡A BUFFER'A
  dragging.forEach(p=>{
    pieces.forEach(o=>{
      if (o === p || o.locked) return;
      if (o.x === p.x && o.y === p.y) {
        moveToBuffer(o);
      }
    });
  });

  dragging.forEach(p=>{
    p.el.style.left = p.x*PW+"px";
    p.el.style.top  = p.y*PH+"px";
    p.el.classList.remove("dragging");
  });

  pointerId = null;
  dragging = null;

  checkLockAndMerge();
}

/* ================= BUFFER ================= */
function moveToBuffer(piece) {
  for (let x=0;x<COLS;x++) {
    if (!pieces.find(p=>p.x===x && p.y===ROWS)) {
      piece.x = x;
      piece.y = ROWS;
      return;
    }
  }
}

/* ================= LOCK + MERGE + WIN ================= */
function checkLockAndMerge() {
  pieces.forEach(p=>{
    if (!p.locked && p.x===p.cx && p.y===p.cy) {
      p.locked = true;
      p.el.classList.add("locked");
    }
  });

  for (let a of pieces) for (let b of pieces) {
    if (a.gid===b.gid || !a.locked || !b.locked) continue;
    const right = a.cx+1===b.cx && a.x+1===b.x && a.y===b.y;
    const down  = a.cy+1===b.cy && a.y+1===b.y && a.x===b.x;
    if (right || down) {
      groups[b.gid].forEach(p=>{
        p.gid = a.gid;
        groups[a.gid].push(p);
      });
      delete groups[b.gid];
      break;
    }
  }

  if (pieces.every(p=>p.locked)) {
    document.getElementById("win").classList.add("show");
    navigator.vibrate?.([100,50,100]);
  }
}
</script>

</body>
</html>
