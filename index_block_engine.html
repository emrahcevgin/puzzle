<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Block Puzzle Engine</title>

<style>
body{
  margin:0;
  background:#111;
  color:#fff;
  font-family:Arial;
  display:flex;
  flex-direction:column;
  align-items:center;
}
#top{padding:10px}
#board{
  position:relative;
  background:#000;
  border:2px solid #333;
  touch-action:none;
}
.block-piece{
  position:absolute;
  border:1px solid #222;
  background-repeat:no-repeat;
  transition:left .2s, top .2s;
}
.block-piece.dragging{transition:none;z-index:10}
</style>
</head>

<body>

<div id="top">
  <input type="file" id="file" accept="image/*">
</div>
<div id="board"></div>

<script>
/* ===== CONFIG ===== */
var ROWS=3, COLS=5;

/* ===== STATE ===== */
var PW,PH;
var blocks=[]; // {id, pieces:[{cx,cy,x,y,el}]}
var draggingBlock=null;
var pointerId=null;
var ox=0, oy=0;

/* ===== DOM ===== */
var board=document.getElementById("board");
var input=document.getElementById("file");

/* ===== IMAGE LOAD ===== */
input.onchange=function(){
  var f=input.files[0];
  if(!f) return;
  var r=new FileReader();
  r.onload=function(e){ init(e.target.result); };
  r.readAsDataURL(f);
};

function init(src){
  board.innerHTML="";
  blocks=[];

  var img=new Image();
  img.onload=function(){
    var maxW=innerWidth*0.95;
    var maxH=innerHeight*0.7;
    var ratio=img.width/img.height;
    var W=maxW, H=W/ratio;
    if(H>maxH){ H=maxH; W=H*ratio; }

    PW=W/COLS;
    PH=H/ROWS;
    board.style.width=W+"px";
    board.style.height=H+"px";

    var id=0;
    for(var y=0;y<ROWS;y++){
      for(var x=0;x<COLS;x++){
        var el=document.createElement("div");
        el.className="block-piece";
        el.style.width=PW+"px";
        el.style.height=PH+"px";
        el.style.backgroundImage="url("+src+")";
        el.style.backgroundSize=W+"px "+H+"px";
        el.style.backgroundPosition=(-x*PW)+"px "+(-y*PH)+"px";
        board.appendChild(el);

        var piece={cx:x,cy:y,x:x,y:y,el:el};
        var block={id:id,pieces:[piece]};
        blocks.push(block); id++;

        el.onpointerdown=(function(b,p){
          return function(e){ startDrag(e,b,p); };
        })(block,piece);
      }
    }

    shuffleBlocks();
    drawAll();
  };
  img.src=src;
}

/* ===== SHUFFLE ===== */
function shuffleBlocks(){
  var cells=[];
  for(var y=0;y<ROWS;y++)
    for(var x=0;x<COLS;x++)
      cells.push({x:x,y:y});
  cells.sort(function(){return Math.random()-0.5});
  blocks.forEach(function(b,i){
    b.pieces[0].x=cells[i].x;
    b.pieces[0].y=cells[i].y;
  });
}

/* ===== DRAG ===== */
function startDrag(e,block,piece){
  if(pointerId!==null) return;
  pointerId=e.pointerId;
  draggingBlock=block;

  var rect=piece.el.getBoundingClientRect();
  ox=e.clientX-rect.left;
  oy=e.clientY-rect.top;

  block.pieces.forEach(function(p){
    p.el.classList.add("dragging");
  });

  piece.el.setPointerCapture(pointerId);
}

board.onpointermove=function(e){
  if(!draggingBlock||e.pointerId!==pointerId) return;
  var boardRect=board.getBoundingClientRect();
  var base=draggingBlock.pieces[0];

  draggingBlock.pieces.forEach(function(p){
    p.el.style.left=
      e.clientX-boardRect.left-ox+(p.x-base.x)*PW+"px";
    p.el.style.top =
      e.clientY-boardRect.top -oy+(p.y-base.y)*PH+"px";
  });
};

board.onpointerup=endDrag;
board.onpointercancel=endDrag;

/* ===== DROP + BLOCK KAYMA ===== */
function endDrag(){
  if(!draggingBlock) return;

  var base=draggingBlock.pieces[0];
  var nx=Math.round(base.el.offsetLeft/PW);
  var ny=Math.round(base.el.offsetTop /PH);

  var targets=[];
  draggingBlock.pieces.forEach(function(p){
    targets.push({p:p,x:nx+(p.x-base.x),y:ny+(p.y-base.y)});
  });

  var occ=buildOccupancy(draggingBlock);

  targets.forEach(function(t){
    var hit=occ[t.y] && occ[t.y][t.x];
    if(hit && hit!==draggingBlock){
      shiftBlock(hit,occ);
    }
  });

  targets.forEach(function(t){
    t.p.x=t.x;
    t.p.y=t.y;
    occ[t.y][t.x]=draggingBlock;
  });

  draggingBlock.pieces.forEach(function(p){
    p.el.classList.remove("dragging");
  });

  draggingBlock=null;
  pointerId=null;

  mergeBlocks();
  drawAll();
}

/* ===== OCCUPANCY ===== */
function buildOccupancy(ignore){
  var o=[];
  for(var y=0;y<ROWS;y++){
    o[y]=[];
    for(var x=0;x<COLS;x++) o[y][x]=null;
  }
  blocks.forEach(function(b){
    if(b===ignore) return;
    b.pieces.forEach(function(p){
      o[p.y][p.x]=b;
    });
  });
  return o;
}

/* ===== SHIFT BLOCK ===== */
function shiftBlock(block,occ){
  var cells=[];
  for(var y=0;y<ROWS;y++)
    for(var x=0;x<COLS;x++)
      if(!occ[y][x]) cells.push({x:x,y:y});

  if(!cells.length) return;

  var base=block.pieces[0];
  var dest=cells[0];

  block.pieces.forEach(function(p){
    occ[p.y][p.x]=null;
    p.x=dest.x+(p.x-base.x);
    p.y=dest.y+(p.y-base.y);
  });

  block.pieces.forEach(function(p){
    occ[p.y][p.x]=block;
  });
}

/* ===== MERGE ===== */
function mergeBlocks(){
  for(var i=0;i<blocks.length;i++){
    for(var j=0;j<blocks.length;j++){
      if(i===j) continue;
      var A=blocks[i], B=blocks[j];
      if(canMerge(A,B)){
        A.pieces=A.pieces.concat(B.pieces);
        blocks.splice(j,1);
        return mergeBlocks();
      }
    }
  }
}

function canMerge(A,B){
  for(var i=0;i<A.pieces.length;i++){
    for(var j=0;j<B.pieces.length;j++){
      var a=A.pieces[i], b=B.pieces[j];
      var right=a.cx+1===b.cx && a.x+1===b.x && a.y===b.y;
      var down =a.cy+1===b.cy && a.y+1===b.y && a.x===b.x;
      if(right||down) return true;
    }
  }
  return false;
}

/* ===== DRAW ===== */
function drawAll(){
  blocks.forEach(function(b){
    b.pieces.forEach(function(p){
      p.el.style.left=(p.x*PW)+"px";
      p.el.style.top =(p.y*PH)+"px";
    });
  });
}
</script>

</body>
</html>
